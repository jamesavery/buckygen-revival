# Progress — Step 3: Canonical Construction Path (COMPLETE)

## Status: C60 generation CORRECT — Rule 2 COMPLETE, zero duplicates

## Reference Documents
- `C-CODE-ALGORITHM.md` — **AUTHORITATIVE**: complete algorithm as reverse-engineered from C code
- `BUCKYGEN-MAP.md` — mapping between paper, C code, and Haskell (function index, line numbers)
- `buckygen_paper_source/` — original paper (has significant gaps; see C-CODE-ALGORITHM.md)

## Files
- `Seeds.hs` (920 lines) — Step 1 (complete) + EdgeList type, initEdgeList, 4-field DualGraph
- `Expansion.hs` (~1330 lines) — Core implementation including F (nanotube ring) expansion/reduction
- `Spiral.hs` (297 lines) — Canonical generalized spiral computation
- `Canonical.hs` (~770 lines) — McKay's canonical construction path test + automorphisms + Rule 2
- `TestCanonical.hs` (~411 lines) — Generation with canonical test + Rule 2 + spiral dedup
- `TestExpansion.hs` (~509 lines) — Comprehensive tests
- `Generate.hs` (252 lines) — Generation sanity check with isomorphism deduplication + cross-check
- `GenTestData60.hs` (139 lines) — Test data generator (all graphs up to C60)
- `TestGraphs60.hs` (5790 lines) — Generated test data (5770 graphs with canonical spirals)

## Generation Counts (ALL 21 sizes pass through C60)

```
Dual V  C_n     Found       Expected    Status
----------------------------------------------------
12      C20     1           1           PASS
14      C24     1           1           PASS
15      C26     1           1           PASS
16      C28     2           2           PASS
17      C30     3           3           PASS
18      C32     6           6           PASS
19      C34     6           6           PASS
20      C36     15          15          PASS
21      C38     17          17          PASS
22      C40     40          40          PASS
23      C42     45          45          PASS
24      C44     89          89          PASS
25      C46     116         116         PASS
26      C48     199         199         PASS
27      C50     271         271         PASS
28      C52     437         437         PASS
29      C54     580         580         PASS
30      C56     924         924         PASS
31      C58     1205        1205        PASS
32      C60     1812        1812        PASS
```

## Current Architecture

### Canonical test (Rule 1): 5-tuple cascade
```
(x0, x1, x2, x3, x4) = (reductionLength, -longestStraight, colourPair, pathColour, BFS)
```

### Automorphism group: `canonicalBFSAndGroup`
- Tries all (vertex, neighbor, direction) starting edges
- Edges producing the minimum BFS code define automorphisms
- Returns `CanonResult` with code, automorphism list, and nbop count

### Rule 2: `filterByRule2`
- Partitions expansion sites into equivalence classes
- Each class generated by: automorphism images + other-triple equivalence
- Eliminates ~45% of expansion sites

### Rule 1 (isCanonical): direction-specific inverse test
- Identifies the inverse reduction by: same kind, both vertices new, same direction
- The direction-specific test (Bug #15) is the key insight: the C code tests the
  expansion's edge in its SPECIFIC direction, rejecting if the other direction is better
- This single check eliminates all duplicates — no additional Rule 2 orbit extensions needed

### Generation loop (TestCanonical.hs)
1. Compute automorphism group for seeds
2. For each parent: enumerate expansions, filter by Rule 2, apply canonical test
3. Compute child's automorphism group for recursion
4. Spiral dedup as safety net (currently catches 0 duplicates)

## Bugs Fixed

### Bug #15: Direction-specific canonical test (session 18)
The C code's `is_best_L0_reduction` tests the new edge in the SPECIFIC direction used
by the expansion. If the other direction has a better canonOrd, the expansion is rejected.
Our `isInverseRed` was matching ALL directions at new vertices.

**Discovery**: C28's `(0,1) DLeft` and `(0,1) DRight` both passed isCanonical. C code
instrumentation showed `L0 colour_reject: nv=18 from edge 4-0 use_next=1`.

**Fix**: Added `d == dir` to `isInverseRed`, extracting `dir` from the expansion pattern.

**Effect**: Dedup catches 4,268 → 0. This single fix subsumes the L0 reverse equivalence
issue (Bug #16 attempted) — the direction-specific test already rejects the duplicate direction.

### Bug #14: isInverseRed too loose — required both vertices new (session 17)
Previously only checked that the start vertex was new. A new degree-5 vertex adjacent to
an existing degree-5 vertex created spurious L0 reduction matches.

**Fix**: Require both `a` and `b` of the reduction's edge to be within the new vertex range.

**Effect**: Dedup catches 10,109 → 4,268.

### Bug #13: canBentPath incorrectly required par[last] degree-5 (session 16)
**Fix**: Removed `deg g qLast == 5` from `canBentPath`. Now 1812/1812 C60 isomers found.

### Bug #12: L_i reduction enumeration used expansion-site criteria (session 12)
### Bug #11: L0 expansion enumeration too restrictive (session 11)

## Performance (C60 run)

```
Expansion sites before Rule 2: 1,246,398
Expansion sites after Rule 2:    685,824 (Rule 2 eliminated 560,574, 45%)
Would survive Lemma 3 bound:     923,864 (saves 26% of total)
Canon acceptance rate:              5,764 / 685,824 (1%)
Dedup catches:                          0
```

## Key Decisions
- Direction-specific canonical test (Bug #15) eliminates all duplicates without
  needing L0 reverse equivalence or or_same_edge_found in Rule 2
- Spiral dedup remains as safety net but currently catches 0 duplicates

## Next Steps (in priority order)
1. **Implement bounding lemmas** (Lemma 3 first: L0 → max pathlength 3)
   - Saves 26% of expansion sites
2. Step 4: Forest traversal with SearchMonad abstraction
3. Step 5: Additional bounding lemmas (Lemmas 4, 5, 6)
