# Progress — Buckygen Rewrite

## Status: C60 generation CORRECT — Algorithm specification COMPLETE

## Latest: BUCKYGEN-ALGORITHM.md written (2026-02-16)
- Self-contained 954-line algorithm specification in `doc/BUCKYGEN-ALGORITHM.md`
- Fills all 15 gaps identified in `doc/BUCKYPAPER.md` (paper analysis)
- Designed to be implementable from scratch without any other reference
- Covers: graph representation, seeds, expansions, reductions, canonical test (5-tuple),
  Rule 2 orbit filtering, generation loop, bounding lemmas, worked example, validation data

## Reference Documents
- `BUCKYGEN-ALGORITHM.md` — **COMPLETE SPECIFICATION**: self-contained algorithm description
- `C-CODE-ALGORITHM.md` — algorithm as reverse-engineered from C code
- `BUCKYGEN-MAP.md` — mapping between paper, C code, and Haskell (function index, line numbers)
- `BUCKYPAPER.md` — analysis of 15 gaps/errors in the original buckygen paper
- `buckygen_paper_source/` — original paper (has significant gaps; see BUCKYPAPER.md)

## Files
- `Seeds.hs` (920 lines) — Step 1 (complete) + EdgeList type, initEdgeList, 7-field DualGraph (IntMap + Array caches)
- `Expansion.hs` (~1330 lines) — Core implementation including F (nanotube ring) expansion/reduction
- `Spiral.hs` (297 lines) — Canonical generalized spiral computation
- `Canonical.hs` (~770 lines) — McKay's canonical construction path test + automorphisms + Rule 2
- `TestCanonical.hs` (~411 lines) — Generation with canonical test + Rule 2 + spiral dedup
- `TestExpansion.hs` (~509 lines) — Comprehensive tests
- `Generate.hs` (252 lines) — Generation sanity check with isomorphism deduplication + cross-check
- `GenTestData60.hs` (139 lines) — Test data generator (all graphs up to C60)
- `TestGraphs60.hs` (5790 lines) — Generated test data (5770 graphs with canonical spirals)

## Generation Counts (ALL 21 sizes pass through C60)

```
Dual V  C_n     Found       Expected    Status
----------------------------------------------------
12      C20     1           1           PASS
14      C24     1           1           PASS
15      C26     1           1           PASS
16      C28     2           2           PASS
17      C30     3           3           PASS
18      C32     6           6           PASS
19      C34     6           6           PASS
20      C36     15          15          PASS
21      C38     17          17          PASS
22      C40     40          40          PASS
23      C42     45          45          PASS
24      C44     89          89          PASS
25      C46     116         116         PASS
26      C48     199         199         PASS
27      C50     271         271         PASS
28      C52     437         437         PASS
29      C54     580         580         PASS
30      C56     924         924         PASS
31      C58     1205        1205        PASS
32      C60     1812        1812        PASS
```

## Current Architecture

### Canonical test (Rule 1): 5-tuple cascade
```
(x0, x1, x2, x3, x4) = (reductionLength, -longestStraight, colourPair, pathColour, BFS)
```

### Automorphism group: `canonicalBFSAndGroup`
- Tries all (vertex, neighbor, direction) starting edges
- Edges producing the minimum BFS code define automorphisms
- Returns `CanonResult` with code, automorphism list, and nbop count

### Rule 2: `filterByRule2`
- Partitions expansion sites into equivalence classes
- Each class generated by: automorphism images + other-triple equivalence
- Eliminates ~45% of expansion sites

### Rule 1 (isCanonical): direction-specific inverse test
- Identifies the inverse reduction by: same kind, both vertices new, same direction
- The direction-specific test (Bug #15) is the key insight: the C code tests the
  expansion's edge in its SPECIFIC direction, rejecting if the other direction is better
- This single check eliminates all duplicates — no additional Rule 2 orbit extensions needed

### Generation loop (TestCanonical.hs)
1. Compute automorphism group for seeds
2. For each parent: enumerate expansions, filter by Rule 2, apply canonical test
3. Compute child's automorphism group for recursion
4. Spiral dedup as safety net (currently catches 0 duplicates)

## Bugs Fixed

### Bug #15: Direction-specific canonical test (session 18)
The C code's `is_best_L0_reduction` tests the new edge in the SPECIFIC direction used
by the expansion. If the other direction has a better canonOrd, the expansion is rejected.
Our `isInverseRed` was matching ALL directions at new vertices.

**Discovery**: C28's `(0,1) DLeft` and `(0,1) DRight` both passed isCanonical. C code
instrumentation showed `L0 colour_reject: nv=18 from edge 4-0 use_next=1`.

**Fix**: Added `d == dir` to `isInverseRed`, extracting `dir` from the expansion pattern.

**Effect**: Dedup catches 4,268 → 0. This single fix subsumes the L0 reverse equivalence
issue (Bug #16 attempted) — the direction-specific test already rejects the duplicate direction.

### Bug #14: isInverseRed too loose — required both vertices new (session 17)
Previously only checked that the start vertex was new. A new degree-5 vertex adjacent to
an existing degree-5 vertex created spurious L0 reduction matches.

**Fix**: Require both `a` and `b` of the reduction's edge to be within the new vertex range.

**Effect**: Dedup catches 10,109 → 4,268.

### Bug #13: canBentPath incorrectly required par[last] degree-5 (session 16)
**Fix**: Removed `deg g qLast == 5` from `canBentPath`. Now 1812/1812 C60 isomers found.

### Bug #12: L_i reduction enumeration used expansion-site criteria (session 12)
### Bug #11: L0 expansion enumeration too restrictive (session 11)

## Performance (C60 run)

### Current (with all optimizations, 2026-02-16)
```
Time: 12.1s  |  Allocation: 71 GB  |  Zero duplicates
Expansion sites (bounded):     379,920
After Rule 2:                  180,951 (Rule 2 eliminated 52%)
Canon acceptance rate:           5,764 / 180,951 (3%)
```

### Optimization history
| Optimization | Time | Alloc | Speedup |
|---|---|---|---|
| Baseline (no bounds) | 310s | ~1 TB | 1.0x |
| + Bounding lemmas 1-5 | 170s | 467 GB | 1.8x |
| + allReductionsUpTo | 25.5s | 66.6 GB | **12.2x** |
| + boxed Array caches | 23.5s | 66.6 GB | 13.2x |
| + flat UArray (adjFlat/degFlat) | **12.1s** | 71 GB | **25.6x** |
| C reference (buckygen.c) | 0.02s | — | ~15000x |

Key wins:
- `allReductionsUpTo`: Skip bent reduction enumeration when expansion length ≤ 2 (6.7x)
- Flat `UArray Int Int` for navigation: unboxed contiguous memory, linear scan for
  indexOf (5-6 entries), `nbrAt` = single array index. Eliminated all navigation
  primitives from the profile (were 25%+ of time). (1.9x over boxed Array)
- STUArray for BFS was a net negative (too many small mutable array allocations per
  canonicity check). Reverted to pure IntMap BFS.
- Remaining gap to C: ~600x

### Profile distribution (C40, post flat UArray)
```
straightAhead 7.3%  |  isValidB00 5.4%  |  bfsDistance 5.0%  |  bfsCF.procNbrs 4.6%
bentPath.adv 4.2%   |  hasDups 3.8%     |  bentZeroPath 3.1% |  bentPath 2.7%
```
Navigation primitives (indexOf, advanceCW, deg, nextCW, prevCW) have disappeared
from the profile. Remaining time is distributed across algorithm logic and BFS.

## Key Decisions
- Direction-specific canonical test (Bug #15) eliminates all duplicates without
  needing L0 reverse equivalence or or_same_edge_found in Rule 2
- Spiral dedup remains as safety net but currently catches 0 duplicates

## Next Steps (in priority order)
1. **Algorithmic optimization**: Avoid materializing full graphs — compute canonOrd
   components lazily from the parent + expansion diff
2. **Mutable representation**: ST-based graph for O(1) in-place surgery
3. **BFS allocation**: Replace IntMap with UArray in BFS traversal
4. **Forest traversal**: SearchMonad abstraction with parallel strategies
