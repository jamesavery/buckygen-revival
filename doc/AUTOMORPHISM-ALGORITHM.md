# Automorphism Group Computation and Rule 2 Implementation

## Purpose

This document describes how to compute the automorphism group of a fullerene
dual graph as a byproduct of BFS canonical form, and how to use it for Rule 2
(only try one expansion per equivalence class). This eliminates the need for
spiral dedup and is the architecturally correct approach.

**Measured impact (C50 run):** Without Rule 2, the generation loop produces
6,309 duplicate graphs caught by spiral dedup, out of 7,116 canonical test
passes. That means 89% of canonical test passes are wasted on duplicates.
Rule 2 eliminates all of them at the source.

---

## 1. Background: Why Automorphisms Matter

### The duplication problem

Each reduction of a child graph G' has exactly **two representing triples**
(one from each endpoint of the central path). Additionally, if the parent
graph G has a non-trivial automorphism group, multiple expansion sites map
to each other under automorphisms, producing isomorphic children.

Without Rule 2, all equivalent expansion sites are tried, all produce
isomorphic children, all pass the canonical test (Rule 1), and duplicates
must be caught downstream (currently via spiral dedup).

### The two sources of equivalence

The paper (Section 2.2, lines 333-340) defines equivalence on expansion
triples as generated by two relations:

1. **Two-triple relation**: Each reduction has two representing triples
   `(e1, params, d)` and `(e2, params', d')`, one from each endpoint of the
   central path. These always produce the same child graph.

2. **Automorphism relation**: If σ is an automorphism of G, then expansion
   sites `(e, params, d)` and `(σ(e), params, d')` produce isomorphic children.
   Direction `d' = d` for orientation-preserving σ, `d' = flip(d)` for
   orientation-reversing σ.

Rule 2 says: only try one expansion per equivalence class under both relations.

---

## 2. How Automorphisms Emerge from BFS

### The key insight

The BFS canonical form is the lexicographic minimum over all starting
configurations `(vertex, neighbor, direction)`. Each starting configuration
that produces the minimum code defines an automorphism.

Given starting edge (u₁→v₁, dir₁) producing BFS numbering φ₁ and starting
edge (u₂→v₂, dir₂) producing BFS numbering φ₂, if both produce the same
BFS code, then the mapping σ(w) = φ₂⁻¹(φ₁(w)) is an automorphism.

- If dir₁ = dir₂: σ is orientation-preserving
- If dir₁ ≠ dir₂: σ is orientation-reversing

### What the C code does

The C code's `testcanon()` function (line 2246) compares a BFS code against
a reference (`representation[]`) and returns:

- **0**: Worse code (not an automorphism, not canonical)
- **1**: Same code (IS an automorphism)
- **2**: Better code (new canonical representative)

The `canon_edge_oriented()` function (line 4088) processes candidate starting
edges and collects all that return 1 (automorphisms). It stores them via
`construct_numb()` (line 3150) which records the complete edge traversal
sequence in `numbering[i][]` for each automorphism i.

The result is:
- `nbtot`: total number of automorphisms
- `nbop`: number of orientation-preserving automorphisms
- `numbering[0..nbtot-1][]`: edge permutations for each automorphism

### The `numbering[][]` array

`numbering[i][k]` is an EDGE pointer. For automorphism i, it maps the k-th
edge in the canonical traversal to the k-th edge in the i-th automorphism's
traversal. Two edges at the same index k across different automorphisms i, j
are related by the automorphism σᵢ⁻¹ ∘ σⱼ.

Crucially, `numbering[0]` is the identity (canonical traversal). So
`numbering[j][k]` gives the image of edge `numbering[0][k]` under
automorphism j.

---

## 3. Haskell Representation

### Current BFS code (Canonical.hs)

```haskell
bfsCanonicalForm :: DualGraph -> Vertex -> Vertex -> Dir -> BFSCode
bfsCanonicalForm g u v dir = BFS code
  where
    -- numMap: vertex → BFS number (1-indexed)
    -- refMap: BFS number → (vertex, reference_neighbor)
    code = go (IM.fromList [(u, 1), (v, 2)])
              (IM.fromList [(1, (u, v)), (2, (v, u))])
              3 1
    go numMap refMap nextNum curNum = ...
```

The function already builds `numMap :: IntMap Int` internally (vertex → BFS
number). We just need to also return it.

### Proposed types

```haskell
-- | Orientation of an automorphism relative to the canonical orientation.
data Orientation = Preserving | Reversing
    deriving (Eq, Show)

-- | An automorphism is a vertex permutation + orientation.
-- autPerm maps original vertex → image vertex.
data Automorphism = Aut
    { autPerm        :: !(IntMap Int)    -- vertex → vertex
    , autOrientation :: !Orientation
    } deriving (Show)

-- | Result of canonical BFS computation.
data CanonResult = CanonResult
    { canonCode  :: !BFSCode
    , canonAuts  :: ![Automorphism]   -- includes identity
    , canonNbop  :: !Int              -- count of orientation-preserving auts
    } deriving (Show)
```

---

## 4. Algorithm: `canonicalBFSAndGroup`

### Step 1: Extend `bfsCanonicalForm` to return the numbering

```haskell
-- | BFS from a single starting edge, returning both code and vertex numbering.
-- The numbering maps each vertex to its BFS number (1-indexed).
bfsWithNumbering :: DualGraph -> Vertex -> Vertex -> Dir
                 -> (BFSCode, IntMap Int)
```

This is a minimal modification of the existing `bfsCanonicalForm`: just
return `numMap` alongside `code`.

### Step 2: Try all starting edges, find minimum, collect automorphisms

```haskell
canonicalBFSAndGroup :: DualGraph -> CanonResult
canonicalBFSAndGroup g =
    -- Try all (vertex, neighbor, direction) starting configurations.
    -- Track the minimum code and all configurations that achieve it.
    let nv = numVertices g
        allStarts = [ (u, v, d)
                    | u <- [0..nv-1]
                    , v <- nbrs g u
                    , d <- [DLeft, DRight]
                    ]
    in foldl' processStart initial allStarts
```

For each starting configuration `(u, v, d)`:
1. Compute `(code, numMap) = bfsWithNumbering g u v d`
2. Compare `code` against `bestCode`:
   - If `code < bestCode`: new canonical. Reset: bestCode = code,
     bestNumMap = numMap, bestDir = d, matches = [(numMap, d)]
   - If `code == bestCode`: automorphism found. Append (numMap, d) to matches.
   - If `code > bestCode`: skip.

### Step 3: Convert matches to automorphisms

After processing all starts, we have:
- `bestNumMap`: vertex → BFS number for the canonical starting edge
- `bestDir`: direction of the canonical starting edge
- `matches`: list of (numMap, dir) for all starts that achieve the minimum

For each match `(φ, d)`:
- Compute the inverse of `bestNumMap`: `bestInv :: IntMap Int`
  (BFS number → original vertex)
- The automorphism permutation: `σ(v) = bestInv ! (φ ! v)` for each vertex v
- Orientation: `Preserving` if `d == bestDir`, `Reversing` if `d /= bestDir`

The identity automorphism is always present (the canonical starting edge
matches itself, giving σ = id).

### Pseudocode

```
canonicalBFSAndGroup(g):
    bestCode = +∞
    bestNumMap = ∅
    bestDir = DLeft
    matches = []

    for u in 0..nv-1:
        for v in nbrs(g, u):
            for d in [DLeft, DRight]:
                (code, numMap) = bfsWithNumbering(g, u, v, d)
                if code < bestCode:
                    bestCode = code
                    bestNumMap = numMap
                    bestDir = d
                    matches = [(numMap, d)]
                elif code == bestCode:
                    matches.append((numMap, d))

    bestInv = invert(bestNumMap)   -- BFS number → vertex
    auts = []
    nbop = 0
    for (φ, d) in matches:
        σ = { v → bestInv[φ[v]] | v ∈ vertices }
        ori = Preserving if d == bestDir else Reversing
        auts.append(Aut σ ori)
        if ori == Preserving: nbop += 1

    return CanonResult bestCode auts nbop
```

### Complexity

- Number of starting configurations: 2 × |directed edges| = 2 × Σ deg(v)
  For fullerene duals: avg degree ≈ 5.6, so ~11.2n configurations
- Each BFS: O(n) to produce the code
- Total: O(n²) per graph

The C code optimizes with **incremental early-exit comparison**: most
starting edges produce a worse code and are rejected after examining only
a few entries. This makes the average case much faster. We can add this
optimization later; correctness first.

### Early-exit optimization (for later)

Instead of computing the full BFS code for every starting edge, compare
incrementally against the current best:

```haskell
-- | Compare BFS from (u,v,d) against reference code.
-- Returns: LT (worse), EQ (automorphism), GT (better canonical).
-- Aborts as soon as a difference is found.
bfsCompare :: DualGraph -> Vertex -> Vertex -> Dir
           -> [Int]        -- reference code
           -> (Ordering, IntMap Int)  -- result + numbering if EQ
```

This would replace the full `bfsWithNumbering` in most calls, only
constructing the full numbering when the code matches (EQ case).

---

## 5. Using Automorphisms for Rule 2

### Expansion orbit computation

Given the automorphism group Aut(G) of parent graph G and a list of
expansion sites, Rule 2 keeps one representative per equivalence class.

For expansion `Exp kind (u, v) dir`, its image under `Aut σ ori` is:

```haskell
applyAutToExp :: Automorphism -> Expansion -> Expansion
applyAutToExp (Aut σ Preserving) (Exp kind (u, v) dir) =
    Exp kind (σ ! u, σ ! v) dir
applyAutToExp (Aut σ Reversing) (Exp kind (u, v) dir) =
    Exp kind (σ ! u, σ ! v) (flipDir dir)
```

### The two-triple equivalence

In addition to automorphism equivalence, each expansion has an "other triple"
from the other endpoint of the path. These must also be treated as equivalent.

For each expansion type, the other triple is:

#### L0: `Exp (L 0) (u, v) d`

Path: u → v₁ → v₂ where v₂ = par[2] (degree-5).
Other triple: computed by following the path from the other end.
The C code (find_L0_extensions_next, line 5504):
```c
other_startedge = e->invers->next->next->invers->next;
```
In Haskell: compute the straight path, then the other triple starts from
par[2] at the other end of the path.

**Concretely:** Given `Exp (L 0) (u, v) d`, compute `PathInfo path par`.
The other triple is `Exp (L 0) (par!!2, v') d` where v' is determined by
the path from par[2]'s perspective. Since both triples represent the same
reduction, they have the same kind and direction.

#### L_i (i≥1): `Exp (L i) (u, v) d`

Path goes from u (degree-5) through i+1 intermediate vertices to w (degree-5).
Other triple: `Exp (L i) (w, prev_w) d` where prev_w is the penultimate
vertex on the path.

The C code (find_straight_extensions_next, line 5847):
```c
temp_edge = e->invers->next->next->invers->next;
mark_edges_straight(temp_edge, i, 1, numb_total, npres);
```

#### B_{0,0}: `Exp (B 0 0) (u, v) d`

The B00 path goes u → v₁ → turn → v₃ → w, where u and w are degree-5.
Other triple: starts from w at the other end.
**Direction flips** for B00: the C code marks the other triple with the
opposite direction (`mark_edges_bent_zero(e->invers, 0, ...)` when
`use_next=1`, and `mark_edges_bent_zero(e->invers, 1, ...)` when
`use_next=0`).

This is because the bent path reverses direction at the turn point: what
looks like a "next" walk from one endpoint looks like a "prev" walk from
the other.

#### B_{i,j} (i+j > 0): `Exp (B i j) (u, v) d`

The other triple starts from the other endpoint with swapped parameters:
`Exp (B j i) (w, prev_w) (flipDir d)`.

The C code (find_bent_extensions_next, line 6373):
```c
mark_edges_bent(e->invers, 0, i - bent_position, i, numb_total, npres);
```
The `i - bent_position` swap reflects that B_{a,b} from one end = B_{b,a}
from the other end.

### Combined equivalence

Two expansions are equivalent if one can be reached from the other by:
1. Applying an automorphism (possibly orientation-reversing), AND/OR
2. Switching to the other triple (other endpoint of the path)

The full orbit of an expansion site is generated by composing both relations.

### Implementation: greedy marking approach

The C code uses a greedy marking approach: iterate through expansion sites,
and for each unmarked site, generate the expansion, then mark all equivalent
sites (automorphic images + other triple + automorphic images of other triple).

For Haskell, the cleanest approach:

```haskell
filterByRule2 :: DualGraph -> [Automorphism] -> [Expansion] -> [Expansion]
filterByRule2 g auts exps = go Set.empty exps
  where
    go _seen [] = []
    go seen (e:rest)
        | expKey e `Set.member` seen = go seen rest
        | otherwise =
            let orbit = fullOrbit g auts e
                seen' = foldl' (\s x -> Set.insert (expKey x) s) seen orbit
            in e : go seen' rest

    -- Canonical key for an expansion (for Set membership)
    expKey (Exp kind (u, v) dir) = (kind, u, v, dir)

    -- Full orbit: all automorphic images + other triple + its images
    fullOrbit g auts e =
        let autImages = [applyAutToExp a e | a <- auts]
            otherTriple = computeOtherTriple g e
            otherImages = case otherTriple of
                Nothing -> []
                Just e' -> [applyAutToExp a e' | a <- auts]
        in autImages ++ otherImages
```

### Computing the other triple

```haskell
computeOtherTriple :: DualGraph -> Expansion -> Maybe Expansion
computeOtherTriple g (Exp (L 0) (u, v) d) =
    -- Compute path, find the other degree-5 vertex (par[2])
    let pi = computeStraightPath g (u, v) d 3
        otherV = parallelPath pi !! 2  -- the other degree-5 vertex
        -- Find the starting edge from otherV that traces back
        -- to the same path (from the other end)
        -- The other edge is the one pointing "into" the path
        -- from otherV's perspective
    in Just (Exp (L 0) (otherV, otherEdge) d)
    -- Note: same direction for L types

computeOtherTriple g (Exp (L i) (u, v) d) =
    -- Follow straight path to find other endpoint w
    let pi = computeStraightPath g (u, v) d (i + 3)
        mp = mainPath pi
        w = last mp
        prevW = mp !! (length mp - 2)
    in Just (Exp (L i) (w, prevW) d)  -- same direction

computeOtherTriple g (Exp (B 0 0) (u, v) d) =
    -- Bent path: other endpoint, direction FLIPS
    let pi = computeBentZeroPath g (u, v) d
        mp = mainPath pi
        w = mp !! 4    -- other degree-5 vertex
        prevW = mp !! 3
    in Just (Exp (B 0 0) (w, prevW) (flipDir d))

computeOtherTriple g (Exp (B i j) (u, v) d) =
    -- Bent path: other endpoint, params swap, direction flips
    let pi = computeBentPath g (u, v) d i (i + j)
        mp = mainPath pi
        w = last mp
        prevW = mp !! (length mp - 2)
    in Just (Exp (B j i) (w, prevW) (flipDir d))

computeOtherTriple _ (Exp F _ _) = Nothing  -- F has no "other triple"
```

**Important detail for L types**: The "other triple" for L_i uses the
SAME direction. This is because L-type paths are symmetric: both ends
see the same walk direction. The C code confirms: `mark_edges_L0` and
`mark_edges_straight` mark the other triple with the same `use_next` flag.

**Important detail for B types**: The "other triple" for B_{i,j} uses the
OPPOSITE direction and swaps i↔j. This is because the bent path reverses
direction at the turn point. The C code confirms: `mark_edges_bent_zero`
and `mark_edges_bent` pass `1 - use_next` for the other triple.

---

## 6. Integration into the Generation Loop

### Current flow (TestCanonical.hs)

```
processTree:
    if spiral-dedup: skip
    else: add to seen set, expandChildren

expandChildren:
    exps = expansions maxLen g        -- ALL expansion sites
    children = [g' | e <- exps,
                     applyExpansion e g,
                     isCanonical e nv g']
    recurse into children via processTree
```

### New flow

```
processTree:
    expandChildren (with parent's automorphism group)

expandChildren(auts):
    exps = expansions maxLen g
    filteredExps = filterByRule2 g auts exps    -- Rule 2
    for e in filteredExps:
        g' = applyExpansion e g
        (canonical, childAuts) = isCanonicalWithAuts e nv g'
        if canonical:
            record g'
            expandChildren(childAuts) on g'     -- recurse with child's group
```

### Key changes

1. **`isCanonical` → `isCanonicalWithAuts`**: The canonical test already
   invokes `canonOrd` which may compute BFS. We extend it to also return
   the child's automorphism group when the child is accepted.

   Actually, there's a subtlety: `isCanonical` currently computes `canonOrd`
   for ALL reductions (which may invoke BFS for each). The automorphism group
   should be computed once via `canonicalBFSAndGroup` and reused.

   Better approach: compute `canonicalBFSAndGroup g'` once for the child.
   Use its canonical BFS code as x4 in `canonOrd`. Use its automorphism
   group for the child's future expansions.

2. **Seeds need initial automorphism groups**: C20, C28, C30 need their
   automorphism groups computed at startup. C20 has 120 automorphisms
   (icosahedral symmetry). C28 has 24 (Td symmetry). C30 has 20 (D5h).

3. **Spiral dedup becomes an assertion**: With Rule 2 active, no duplicates
   should occur. Keep spiral dedup temporarily as `assert (not seen)` to
   verify correctness, then remove.

---

## 7. Relationship to `isCanonical`

### Current `isCanonical` (Canonical.hs:549)

```haskell
isCanonical (Exp kind _ _) parentNV g' =
    case inverseReds of
        [] -> False
        _  -> minimum invOrds <= minimum allOrds
  where
    allReds = allReductions g'
    inverseReds = filter isInverseRed allReds
    invOrds = map (`canonOrd` g') inverseReds
    allOrds = map (`canonOrd` g') allReds
```

This computes `canonOrd` for every reduction, which includes the BFS code
(x4) as a lazy component. The BFS is only forced when earlier components tie.

### Where automorphisms fit

The automorphism group of the child G' is needed for:
1. Passing to the recursive call (Rule 2 for G''s children)
2. Not needed for the canonical test itself (Rule 1)

So we compute `canonicalBFSAndGroup g'` **after** the canonical test passes.
This avoids computing automorphisms for rejected children.

However, there's an optimization opportunity: the canonical test may already
compute BFS codes (as x4) for some reductions. If the canonical test invokes
BFS and finds the minimum, we could extract automorphisms from that same
computation. This is what the C code does: `canon_edge_oriented` is called
during the canonical test and returns both the acceptance decision and the
automorphism group.

### Proposed approach

Phase 1 (correctness): Compute `canonicalBFSAndGroup g'` separately after
`isCanonical` returns True. This duplicates some BFS work but is simpler.

Phase 2 (optimization): Integrate automorphism computation into the
canonical test, avoiding redundant BFS computations.

---

## 8. The `or_same_edge_found` Optimization

The C code checks whether any orientation-reversing automorphism maps an
edge to itself (`numbering[j][index] == e`). If so, expanding in direction
`next` produces the same child as expanding in direction `prev` (the
automorphism relates them). In this case, only one direction is tried.

In Haskell terms: if some `Aut σ Reversing` has `σ(u) = u` and `σ(v) = v`,
then `Exp kind (u, v) DLeft` and `Exp kind (u, v) DRight` are equivalent.
The `filterByRule2` function handles this naturally (both are in the same
orbit), but the C code's explicit check avoids even generating the second one.

---

## 9. Verification Plan

1. **Unit test: C20 automorphism group**
   - C20 (dodecahedron) has |Aut| = 120 (icosahedral symmetry, 60 rotations
     + 60 reflections). So nbop = 60, nbtot = 120.
   - Verify `canonicalBFSAndGroup c20` returns 120 automorphisms.

2. **Unit test: C24 (unique fullerene)**
   - C24 has a specific symmetry group. Verify group size.

3. **Integration test: Rule 2 eliminates all duplicates**
   - Run generation with Rule 2 + spiral dedup assertion.
   - Verify dedup catches = 0 at each size through C50.
   - Verify isomer counts still match known values.

4. **Cross-check: expansion count reduction**
   - With Rule 2, the number of expansion sites tried should be
     significantly smaller. Compare against the instrumentation data:
     at C50, 171,285 expansions → should drop substantially.

---

## 10. Implementation Checklist

### Files to modify

- **Canonical.hs**: Add `bfsWithNumbering`, `canonicalBFSAndGroup`,
  `Automorphism` type, `applyAutToExp`, `computeOtherTriple`, `filterByRule2`

- **TestCanonical.hs**: Change generation loop to:
  1. Compute automorphism group for seeds
  2. Pass group to `expandChildren`
  3. Apply `filterByRule2` before canonical test
  4. Compute child's group after acceptance
  5. Assert spiral dedup catches = 0

### New functions (in dependency order)

1. `bfsWithNumbering :: DualGraph -> Vertex -> Vertex -> Dir -> (BFSCode, IntMap Int)`
   - Minimal change to existing `bfsCanonicalForm`

2. `canonicalBFSAndGroup :: DualGraph -> CanonResult`
   - Try all starting edges, collect matches, convert to automorphisms

3. `applyAutToExp :: Automorphism -> Expansion -> Expansion`
   - Apply vertex permutation + orientation to an expansion

4. `computeOtherTriple :: DualGraph -> Expansion -> Maybe Expansion`
   - Find the other triple for each expansion type

5. `filterByRule2 :: DualGraph -> [Automorphism] -> [Expansion] -> [Expansion]`
   - Greedy marking: keep one per orbit

6. Update `expandChildren` to accept and use `[Automorphism]`

7. Update `processTree` to compute and propagate automorphism groups

### Expected sizes

- `bfsWithNumbering`: ~5 lines changed from existing `bfsCanonicalForm`
- `canonicalBFSAndGroup`: ~40 lines
- `applyAutToExp`: ~5 lines
- `computeOtherTriple`: ~30 lines
- `filterByRule2`: ~20 lines
- Generation loop changes: ~30 lines

Total: ~130 lines of new/modified code.

---

## 11. Performance Notes

### Naive implementation cost

Computing `canonicalBFSAndGroup` tries all ~11n starting edges with O(n) BFS
each = O(n²) per graph. At C60 (n=32, 1812 graphs): ~32 × 11 × 32 × 1812
≈ 20M operations. This is acceptable for correctness-first.

### C code's optimization

The C code's `testcanon` does incremental comparison: it generates the BFS
code one entry at a time and compares against the reference. Most starting
edges diverge (produce worse code) within the first few entries, so the
average cost is O(1) per rejected edge rather than O(n).

To implement this in Haskell: instead of computing the full BFS code and
then comparing, interleave generation and comparison. This is a natural
fit for lazy evaluation — generate the BFS code as a lazy list, and the
comparison `(<=)` on lists will only force as many entries as needed.

```haskell
-- The existing BFS code is already a list [Int].
-- Comparing two BFSCode values with (<=) already short-circuits
-- thanks to the Ord instance for lists!
-- So canonicalBFSAndGroup with lazy BFS codes gets early exit for free.
```

This means the naive Haskell implementation may already benefit from
early exit if we compare lazy BFS codes. The main cost is the overhead
of constructing BFS thunks for each starting edge, which is still
much cheaper than materializing the full code.

### Further optimization: prefilter by starting vertex degree

The canonical BFS code starts with the colour of vertex 2 (the neighbor
of the starting vertex). Since colour = degree + maxN, we can prefilter:
only try starting edges where the starting vertex's degree matches the
best known starting degree. But this optimization is minor and can wait.
