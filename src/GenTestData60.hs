{-# LANGUAGE BangPatterns #-}
-- | Generate all unique fullerene dual graphs up to C60 and output them
-- as a Haskell module with CCW adjacency lists and canonical spirals.
-- For use as test data by other-claude.
--
-- Output: TestGraphs60.hs containing:
--   allTestGraphs :: [(Int, [[Int]], [Int], [(Int, Int)])]
-- where each entry is (C_n, ccw_adjacency, spiral, jumps)

module Main where

import Seeds (DualGraph(..), c20, c28, c30)
import Expansion hiding (intersect)
import qualified Spiral
import qualified Data.IntMap.Strict as IM
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.List (foldl', intercalate)
import System.IO (hFlush, hPutStr, stdout, stderr, hSetBuffering, BufferMode(..))

toSpiralGraph :: DualGraph -> Spiral.Graph
toSpiralGraph g =
    Spiral.mkGraph [ reverse (nbrs g v)
                   | v <- [0 .. numVertices g - 1] ]

-- Generation with general spiral dedup
data GenState = GS
    { gsSeen   :: !(Set Spiral.GeneralSpiral)
    , gsGraphs :: !(Map Int [(DualGraph, Spiral.GeneralSpiral)])
    , gsFailed :: !Int
    }

generate :: Int -> GenState
generate maxDV = foldl' (processTree maxDV) (GS Set.empty Map.empty 0) [c20, c28, c30]

processTree :: Int -> GenState -> DualGraph -> GenState
processTree maxDV st g
    | numVertices g > maxDV = st
    | otherwise =
        let nv = numVertices g
            sg = toSpiralGraph g
        in case Spiral.canonicalGeneralSpiral sg of
            Just gs | Set.member gs (gsSeen st) -> st
            Just gs ->
                let st' = st { gsSeen = Set.insert gs (gsSeen st)
                             , gsGraphs = Map.insertWith (++) nv [(g, gs)] (gsGraphs st) }
                in expandChildren maxDV st' g
            Nothing ->
                let st' = st { gsFailed = gsFailed st + 1 }
                in st'

expandChildren :: Int -> GenState -> DualGraph -> GenState
expandChildren maxDV st g =
    let nv = numVertices g
        maxLen = min 10 (maxDV - nv + 2)
        exps = expansions maxLen g
        children = map (\e -> fst (applyExpansion e g)) exps
        ringChildren = case findNanotubeRing g of
            Just (ring, outer) | nv + 5 <= maxDV -> [applyRing g ring outer]
            _ -> []
    in foldl' (processTree maxDV) st (children ++ ringChildren)

-- Format one graph entry compactly
formatEntry :: DualGraph -> Spiral.GeneralSpiral -> String
formatEntry g gs =
    let nv = numVertices g
        cn = (nv - 2) * 2
        adjLists = [ reverse (nbrs g v) | v <- [0 .. nv - 1] ]
    in "    (" ++ show cn ++ ", "
       ++ show adjLists ++ ", "
       ++ show (Spiral.gsSpiral gs) ++ ", "
       ++ show (Spiral.gsJumps gs) ++ ")"

main :: IO ()
main = do
    hSetBuffering stderr LineBuffering
    hSetBuffering stdout (BlockBuffering (Just 65536))
    let maxDV = 32  -- C60

    hPutStrLn stderr $ "Generating fullerene duals up to C60 (" ++ show maxDV ++ " dual vertices)..."
    let st = generate maxDV
        allGraphs = gsGraphs st
        total = sum [length gs | gs <- Map.elems allGraphs]
    hPutStrLn stderr $ "Total unique graphs: " ++ show total
    hPutStrLn stderr $ "Spiral failures: " ++ show (gsFailed st)

    mapM_ (\dv -> do
        let gs = Map.findWithDefault [] dv allGraphs
            cn = (dv - 2) * 2
        if null gs then return ()
        else hPutStrLn stderr $ "  C" ++ show cn ++ ": " ++ show (length gs)
        ) [12..maxDV]

    -- Output Haskell module
    putStrLn "-- | All unique fullerene dual triangulations up to C60."
    putStrLn "-- Generated by buckygen Haskell expansion + canonical generalized spiral."
    putStrLn "-- Each entry: (C_n, ccw_adjacency_lists, canonical_spiral, jumps)"
    putStrLn "-- CCW adjacency lists are suitable for Spiral.mkGraph."
    putStrLn "-- Canonical spiral + jumps uniquely identify each graph."
    putStrLn "--"
    putStrLn "-- Counts:"

    let counts = [(cn, length gs)
                 | dv <- [12..maxDV]
                 , let gs = Map.findWithDefault [] dv allGraphs
                       cn = (dv - 2) * 2
                 , not (null gs)]
    putStrLn $ "--   " ++ intercalate ", " [("C" ++ show cn ++ "=" ++ show n) | (cn, n) <- counts]
    putStrLn $ "-- Total: " ++ show total ++ " graphs"
    putStrLn ""
    putStrLn "module TestGraphs60 (allTestGraphs, graphsAtSize) where"
    putStrLn ""
    putStrLn "-- | All test graphs: (C_n, ccw_adj_lists, spiral, jumps)"
    putStrLn "allTestGraphs :: [(Int, [[Int]], [Int], [(Int, Int)])]"
    putStrLn "allTestGraphs ="

    -- Collect all entries
    let allEntries = concatMap (\dv ->
            Map.findWithDefault [] dv allGraphs
            ) [12..maxDV]

    case allEntries of
        [] -> putStrLn "  []"
        ((g1,s1):rest) -> do
            putStrLn $ "  [ " ++ formatEntry g1 s1
            mapM_ (\(g, s) -> putStrLn $ "  , " ++ formatEntry g s) rest
            putStrLn "  ]"

    putStrLn ""
    putStrLn "-- | Filter graphs by carbon atom count."
    putStrLn "graphsAtSize :: Int -> [([[Int]], [Int], [(Int, Int)])]"
    putStrLn "graphsAtSize cn = [(adj, sp, j) | (c, adj, sp, j) <- allTestGraphs, c == cn]"

  where
    hPutStrLn h s = do
        hPutStr h (s ++ "\n")
        hFlush h
